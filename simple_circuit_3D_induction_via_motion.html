<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Simple Circuit</title>
		<style>body{ margin: 0;}canvas{ width: 100%; height: 100%;}</style>
	</head>
	<body>
		<script type="module">
import * as THREE from './three.module.js';
import {OrbitControls} from './OrbitControls.js';

// create sene and add light from above and below
let scene = new THREE.Scene();
	scene.add(new THREE.DirectionalLight());
var light=new THREE.DirectionalLight(0xFFFFFF,1); light.position.set(0,-1,0); scene.add(light);

let init_nodes=[new THREE.Vector3(-8,-10,-8),new THREE.Vector3(8,-10,8),new THREE.Vector3(10,-8,10),new THREE.Vector3(10,8,10),
		new THREE.Vector3(8,10,8),new THREE.Vector3(-8,10,-8),new THREE.Vector3(-10,8,-10),new THREE.Vector3(-10,-8,-10)];
let particles = [];
let nodes = [];
let velocity = new THREE.Vector3(0,0.4,0);
let dv = new THREE.Vector3(0,0.01,0);
let multiplier = 1.1;
let counter = 0;
let start = false;
let once = true;
let node={p:init_nodes[0],prev:this,next:this}; nodes.push(node);
for(let i=1;i<init_nodes.length;i++){
	node={	p:init_nodes[i],			// new node
	      	prev:nodes[nodes.length-1],		// link to previous
	      	next:this,				// place holder of next until next node is created
	     };
	nodes[nodes.length-1].next=node;		// link previous to this new node
	nodes.push(node);
}
nodes[0].prev=node; node.next=nodes[0];

// create array of particles to travel circuit; they start in a row along z axis and move to first node
for(let i=0;i<91;i++){
	particles.push({s:new THREE.Mesh(new THREE.SphereGeometry(0.5),new THREE.MeshStandardMaterial({color: 0xff0000})),n:nodes[0]});
	particles[particles.length-1].s.position.set(nodes[0].p.x,nodes[0].p.y,nodes[0].p.z-i);
	scene.add(particles[particles.length-1].s);
}
let node_holder = particles[particles.length-1].n;

let camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 ); camera.position.set(0,20,100);
let renderer = new THREE.WebGLRenderer(); renderer.setSize( window.innerWidth, window.innerHeight ); renderer.setClearColor(0xffffff,1);
document.body.appendChild( renderer.domElement );
var controls = new OrbitControls( camera, renderer.domElement ); controls.update(); renderer.render( scene, camera );

function update_particles(item){
	if(start){item.s.position.add(item.n.p.clone().sub(item.s.position).normalize().multiplyScalar(velocity.length()/2));}
	else{item.s.position.add(item.n.p.clone().sub(item.s.position).normalize().multiplyScalar(0.2));}
	if(item.s.position.clone().sub(item.n.p).length()<0.3){item.n=item.n.next;}
	item.s.position.add(velocity);
}
function update_nodes(item){item.p.add(velocity);}

//let counter = 0.0;
//let show_hide = true;
//function update_rings2(item){item.visible=show_hide;}
//function update_rings1(item,index){
//	if(index==parseInt(counter)){show_hide=true;}else{show_hide=false;}
//	item.forEach(update_rings2);
//}

while(node_holder == particles[particles.length-1].n){particles.forEach(update_particles);}
start = true;
			
function animate() {
	requestAnimationFrame( animate );
  	particles.forEach(update_particles);
  	nodes.forEach(update_nodes);
	//rings.forEach(update_rings1);
	controls.update();			
	renderer.render( scene, camera );
	//counter+=0.01;				
	//if(counter>9){counter=0;}
	//velocity.multiplyScalar(multiplier);
	velocity.add(dv);
	if(velocity.length()>0.6 && once){
		dv.multiplyScalar(-1);
		once;
	}
	if(velocity.length()<0.1){once=true;}
	//if(velocity.length()<0.001){multiplier=1.1;velocity.multiplyScalar(-1);}
}
animate();
</script></body></html>
