<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Simple Circuit</title>
		<style>body{ margin: 0;}canvas{ width: 100%; height: 100%;}</style>
	</head>
	<body>
		<script type="module">
import * as THREE from './three.module.js';
import {OrbitControls} from './OrbitControls.js';

// create sene and add light from above and below
let scene = new THREE.Scene();
	scene.add(new THREE.DirectionalLight());
var light=new THREE.DirectionalLight(0xFFFFFF,1); light.position.set(0,-1,0); scene.add(light);

let init_nodes=[new THREE.Vector3(-8,-25,-8),new THREE.Vector3(8,-25,8),new THREE.Vector3(10,-23,10),
		new THREE.Vector3(10,13,10),new THREE.Vector3(8,15,8),new THREE.Vector3(-8,15,-8),
		new THREE.Vector3(-10,13,-10),new THREE.Vector3(-10,-23,-10)];
init_nodes.forEach(function(item){item.add(new THREE.Vector3(0,-10,0));});
let particles = [];
let nodes = [];
let velocity = new THREE.Vector3(0,0,0);
let dv = new THREE.Vector3(0,0.01,0);
let multiplier = 1.1;
let counter = 0;
let start = false;
let once = true;
let once2 = true;
let forward = true;
let node={p:init_nodes[0],prev:this,next:this}; nodes.push(node);
for(let i=1;i<init_nodes.length;i++){
	node={	p:init_nodes[i],			// new node
	      	prev:nodes[nodes.length-1],		// link to previous
	      	next:this,				// place holder of next until next node is created
	     };
	nodes[nodes.length-1].next=node;		// link previous to this new node
	nodes.push(node);
}
nodes[0].prev=node; node.next=nodes[0];

// create array of particles to travel circuit; they start in a row along z axis and move to first node
for(let i=0;i<131;i++){
	particles.push({s:new THREE.Mesh(new THREE.SphereGeometry(0.5),new THREE.MeshStandardMaterial({color: 0xff0000})),n:nodes[0]});
	particles[particles.length-1].s.position.set(nodes[0].p.x,nodes[0].p.y,nodes[0].p.z-i);
	scene.add(particles[particles.length-1].s);
}
let node_holder = particles[particles.length-1].n;

let camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 ); camera.position.set(0,40,100);
let renderer = new THREE.WebGLRenderer(); renderer.setSize( window.innerWidth, window.innerHeight ); renderer.setClearColor(0xffffff,1);
document.body.appendChild( renderer.domElement );
var controls = new OrbitControls( camera, renderer.domElement ); controls.update(); renderer.render( scene, camera );

function update_particles(item){
	if(start){
		if(forward){item.s.position.add(item.n.p.clone().sub(item.s.position).normalize().multiplyScalar(velocity.length()/2));}
		else{item.s.position.add(item.n.prev.p.clone().sub(item.s.position).normalize().multiplyScalar(velocity.length()/2));}
	}
	else{item.s.position.add(item.n.p.clone().sub(item.s.position).normalize().multiplyScalar(0.2));}
	if(forward){if(item.s.position.clone().sub(item.n.p).length()<0.3){item.n=item.n.next;}}
	else{if(item.s.position.clone().sub(item.n.prev.p).length()<0.3){item.n=item.n.prev;}}
	item.s.position.add(velocity);
}
function update_nodes(item){item.p.add(velocity);}

while(node_holder == particles[particles.length-1].n){particles.forEach(update_particles);}
start = true;
			
function animate() {
	requestAnimationFrame( animate );
  	particles.forEach(update_particles);
  	nodes.forEach(update_nodes);
	controls.update();			
	renderer.render( scene, camera );
	velocity.add(dv);
	if(velocity.length()>0.6 && once){ dv.multiplyScalar(-1); once=false;}
	if(velocity.length()<0.1 && !once){ once=true; forward=!forward;}
}
animate();
</script></body></html>
